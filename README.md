Практична робота №2

Троцюк Андрій ТВ-31 

17 варіант

Завдання 2.1

Напишіть програму для визначення моменту, коли time_t
закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та
64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

Результат:

![image](https://github.com/user-attachments/assets/b3278a72-a52c-4f5f-969b-05cd5b6c9e18)
![image](https://github.com/user-attachments/assets/b03cde7b-0834-42b6-ae42-e3d131966085)

Завдання 2.2

Розгляньте сегменти у виконуваному файлі.
1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для
виконуваного файлу, щоб отримати його загальний розмір, і
запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int,
перекомпілюйте й повторіть вимірювання. Зверніть увагу на
відмінності.
3. Тепер додайте початкове значення в оголошення масиву
(пам’ятайте, що C не змушує вас вказувати значення для кожного
елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на
різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію.
Оголосіть другий великий локальний масив з ініціалізатором.
Повторіть вимірювання. Дані розташовуються всередині функцій,
залишаючись у виконуваному файлі? Яка різниця, якщо масив
ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви
компілюєте для налагодження? Для максимальної оптимізації?
Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;
● сегмент BSS не зберігається у виконуваному файлі (за винятком
примітки щодо його вимог до розміру часу виконання);
● текстовий сегмент більшою мірою піддається перевіркам
оптимізації;
● на розмір файлу a.out впливає компіляція для налагодження, але не
сегменти.

Результат:

Базова програма:

![image](https://github.com/user-attachments/assets/a50fc3af-1c60-4363-a36d-d14708bfa6ce)

Додаємо глобальний масив

![image](https://github.com/user-attachments/assets/b203781c-429a-4d97-ac40-b5d7d1d7db8d)
![image](https://github.com/user-attachments/assets/b0b4ba08-3114-4ea8-99d0-0f2975d84e19)

Додаємо ініціалізацію

![image](https://github.com/user-attachments/assets/dee902d9-a444-4624-8048-9876c91205a7)
![image](https://github.com/user-attachments/assets/ab40ae35-c1d8-4916-99e9-65cde2da2ea3)

Додаємо локальні масиви

![image](https://github.com/user-attachments/assets/db3b41c6-ea37-4301-bec3-fbd42c9fd50d)
![image](https://github.com/user-attachments/assets/1fdf0937-9989-4218-a22d-d4a619ad665f)

Найбільше збільшення розміру виконується, коли ми додаємо глобальні масиви, зокрема масиви з ініціалізаторами, оскільки вони займають пам'ять в сегментах DATA або BSS. Локальні масиви, навіть великі, займають пам'ять тільки в стеку і не змінюють значно загальний розмір програми.

Завдання 2.3

Скомпілюйте й запустіть тестову програму, щоб визначити приблизне
розташування стека у вашій системі:
#include &lt;stdio.h&gt;
int main() {
int i;
printf(&quot;The stack top is near %p\n&quot;, &amp;i);
return 0;
}
Знайдіть розташування сегментів даних і тексту, а також купи всередині
сегмента даних, оголосіть змінні, які будуть поміщені в ці сегменти, і
виведіть їхні адреси.
Збільшіть розмір стека, викликавши функцію й оголосивши кілька
великих локальних масивів. Яка зараз адреса вершини стека?

Результат:

![image](https://github.com/user-attachments/assets/7f8409c5-a6c2-4ab9-abb6-7fe15d60975a)
![image](https://github.com/user-attachments/assets/00d05585-b7d9-434a-9148-4f26b4fc2536)

Тепер додамо великі локальні масиви, щоб збільшити використання стека. Це дозволить побачити, як змінюється адреса вершини стека

![image](https://github.com/user-attachments/assets/79c9752e-be17-40cb-a33a-f461df90fc24)
![image](https://github.com/user-attachments/assets/a84a3e2e-4f91-4f91-93af-bc2cd391d94e)

Початкова адреса стека визначається через адресу локальної змінної. Коли додаються великі локальні масиви, адреса вершини стека змінюється (зменшується), оскільки стек зростає вниз.

Завдання 2.4

Результат:

![image](https://github.com/user-attachments/assets/b110b8af-837c-4279-8865-472b2ffcab4b)
![image](https://github.com/user-attachments/assets/0e26eb44-3c1f-464d-aa33-2962b26e52c2)
![image](https://github.com/user-attachments/assets/621e50b4-5cc5-4a15-813d-3aa141ec7579)

Завдання 2.5

Відомо, що при виклику процедур і поверненні з них процесор
використовує стек.Чи можна в такій схемі обійтися без лічильника команд
(IP), використовуючи замість нього вершину стека? Обґрунтуйте свою
відповідь та наведіть приклади.

Результат:

Стек використовується для збереження адрес повернення при викликах функцій, але він не може повністю замінити IP, тому що стек може зберігати лише дані, а IP вказує на інструкцію для виконання.Втрата IP означає неможливість знати, яку команду виконувати далі.Процесори мають спеціальні регістри для збереження IP, тоді як стек не призначений для цього.
Приклад, що демонструє, як IP використовується для виклику функцій:

![image](https://github.com/user-attachments/assets/cc44276e-f3dd-409d-a1b0-72a3eb25c4db)
![image](https://github.com/user-attachments/assets/7bf7ef05-0bd4-4f76-ba23-7e95a9b714d2)

Це демонструє, що процесор використовує стек для збереження адрес повернення (IP). Без IP ми не зможемо знати, куди повертатися після виклику функцій. Тому тільки вершина стека не може замінити лічильник команд.

Завдання 2.17(індивідуальне)

Дослідіть витік пам’яті у довготривалих процесах.

Результат:

![image](https://github.com/user-attachments/assets/61fb57ce-a713-43fe-b328-58dc8e2186bf)
![image](https://github.com/user-attachments/assets/e7ef3095-ee0e-44aa-9e82-2aa4c67bb452)
![image](https://github.com/user-attachments/assets/bd6639f5-93c2-422b-a4f8-8a25fa8ebd22)


У циклі я виділяю пам'ять через malloc, але вона не звільняється. Це призводить до постійного збільшення використання пам'яті. Ми можемо відслідковувати цей витік через Valgrind. Це дозволяє побачити, як відсутність звільнення пам'яті призводить до постійного збільшення використання пам'яті у процесі.
